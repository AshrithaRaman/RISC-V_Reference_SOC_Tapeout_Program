# Day 4 â€“ GLS, Blocking vs Non-Blocking, and Synth-Sim Mismatch

## ðŸ‘‹ Welcome
Welcome to **Day 4** of the RISC-V Reference SoC Workshop!  
Today, we focus on **Gate-Level Simulation (GLS)**, understanding why simulation may differ from synthesis, and the role of **blocking (=)** and **non-blocking (<=)** assignments in Verilog.  

Hands-on labs show common pitfalls and how to debug mismatches early in the flow.

---

## ðŸ“Œ Topics Covered
- Introduction to Gate-Level Simulation (GLS)  
- Understanding Synthesis-Simulation Mismatch  
- Blocking vs Non-Blocking Assignments in Verilog  
- Labs: GLS & missing sensitivity list issues  
- Labs: Synth-Sim mismatches due to blocking assignments  

---

## 1ï¸âƒ£ Gate-Level Simulation (GLS)

### What is GLS?
GLS is the **post-synthesis simulation** of your design using:  
- Netlist generated by synthesis tools  
- Standard cell libraries  

It ensures that the **behavior of synthesized hardware matches the RTL simulation**.

### Why GLS is Important
- Detect mismatches between RTL and gate-level behavior  
- Check for timing violations like **setup/hold issues**  
- Validate reset and initialization logic in synthesized design  
- Confirm that the final netlist aligns with design intent  

### GLS Workflow
1. Write and simulate **RTL**  
2. Synthesize to generate **netlist**  
3. Run GLS with the same testbench  
4. Compare outputs and debug mismatches  

---

## 2ï¸âƒ£ Synthesis-Simulation Mismatch

### What is a mismatch?
A **synth-sim mismatch** occurs when **RTL simulation outputs â‰  gate-level simulation outputs**.

### Common Causes
- **Uninitialized signals** â†’ RTL may start with X, synthesis assumes 0  
- **Incorrect blocking/non-blocking usage** â†’ can introduce race conditions  
- **Incomplete sensitivity lists** â†’ inferred latches or missed updates  
- **Tool optimizations** â†’ removing signals not affecting outputs  

### Impact
- Functional bugs appear **only after synthesis**  
- Harder to reproduce issues  
- Debugging late in the flow is **time-consuming and costly**  

---

## 3ï¸âƒ£ Blocking vs Non-Blocking Assignments

### Inside `always` Blocks
Verilog has two types of assignments:

### Blocking (=)
- Executed sequentially, one after another
- Each statement completes before the next executes

always @(posedge clk) begin
    a = b;    // executed first
    c = a;    // uses updated value of 'a'
end
### Non-Blocking (<=)
- RHS expressions are evaluated in parallel; assignments happen simultaneously  
- Typically used for **sequential logic (flip-flops)**  

always @(posedge clk) begin
    a <= b;    // evaluated
    c <= a;    // uses old value of 'a'
end
### Labs: GLS & Missing Sensitivity List
Problem: Combinational logic may fail to update when inputs change if sensitivity list is incomplete.

module bad_mux(input i0, input i1, input sel, output reg y);
always @(sel) begin   // âŒ Missing i0/i1
    if (sel)
        y <= i1;
    else
        y <= i0;
end
endmodule
## Observation:

- Changing i0 or i1 without changing sel â†’ y does not update

## Fixed Version:

module good_mux(input i0, input i1, input sel, output reg y);
always @(*) begin     // âœ… Complete sensitivity
    if (sel)
        y = i1;
    else
        y = i0;
end
endmodule
## Takeaways:

- Use @(*) for combinational always blocks
- Ensures all inputs are monitored and prevents latch inference

# Labs: Blocking Assignments Causing Mismatches
## Problematic Code:

module blocking_caveat (
    input a, 
    input b, 
    input c, 
    output reg d
);
reg x;

always @(*) begin
    d = x & c;      // uses old 'x'
    x = a | b;      // updated later
end
endmodule
## Issue:

- d uses old value of x in simulation
- Synthesized hardware evaluates both statements together â†’ mismatch

## Optimized Version:


module blocking_caveat_fixed (
    input a, 
    input b, 
    input c, 
    output reg d
);
reg x;

always @(*) begin
    x = a | b;      // update x first
    d = x & c;      // then use updated x
end
endmodule
## Alternative Using Continuous Assignment:


assign x = a | b;
assign d = x & c;

## Takeaways:

- For combinational logic, blocking assignments must follow proper order
- If ordering is tricky, use continuous assignments or split logic into smaller always blocks

### âœ… Final Takeaways
- GLS validates post-synthesis designs before fabrication

- Always use non-blocking (<=) for sequential always @(posedge clk) blocks

- Use blocking (=) in combinational always @(*) blocks, carefully ordering statements

- Always use @(*) instead of partial sensitivity lists to avoid mismatches
